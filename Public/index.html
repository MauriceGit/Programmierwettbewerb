<!DOCTYPE html>
<html lang="en">
    <head>
    <title>Programmierwettbewerb</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.2/jquery.min.js"></script>
    <script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
        <style>
            .jumbotron {
                background-image: url(Images/GameSample2.jpg);
                color: white;
            }
            .hidden {
                display:none;
            }
            .offset {
                margin-top: 50px;
            }
            h1 {
                margin-bottom: -10px;
            }
            body {
                padding-bottom: 100px;
            }
            .further {
                color: #808080;
            }
            .indent {
                margin-left: 20px ;
            }
            .img-center {
                margin:0 auto;
            }
        </style>
        <script>
            var currentView = "";

            var views = {
                "home": { button:"#mnuHome", htmlContainer:"#mainHTML" },
                "rules": { button:"#mnuRules", htmlContainer:"#rulesHTML" },
                "botDevelopment": { button:"#mnuBotDevelopment", htmlContainer:"#botDevelopmentHTML" },
                "contact": { button:"#mnuContact", htmlContainer:"#contactHTML" },
                "simulations": { button:"#mnuSimulations", htmlContainer:"#simulationsHTML" },
            };

            function openView(name) {
                var mainContainer = $("#container");

                if (currentView != "") {
                    var previousHtmlContainer = $(views[currentView].htmlContainer);
                    var previousButton = $(views[currentView].button);

                    previousHtmlContainer.html(mainContainer.children());
                    previousButton.removeClass("active");
                }

                var currentHtmlContainer = $(views[name].htmlContainer);
                var currentButton = $(views[name].button);

                mainContainer.html(currentHtmlContainer.children());
                currentButton.addClass("active");

                currentView = name;
            }

            $(window).load(function(){
                openView("home");

                function handlerMaker(view) {
                    return function() { openView(view); };
                }

                for (var view in views) {
                    if (views.hasOwnProperty(view)) {
                        $(views[view].button).click(handlerMaker(view));
                    }
                }
            });
        </script>
    </head>
    <body>
        <div id="mainHTML" class="hidden">
            <div id="jumbotron" class="jumbotron">
                <h1>Agar.io</h1>
                <p>FH Wedel - Programmierwettbewerb Wintersemester 2016</p>
            </div>
            <pre>
Da wir aktuell aktiv am Server entwickeln und einiges davon am Live-System testen müssen, kann es sein, dass der Server temporär nicht
erreichbar ist oder neu gestartet wird.
Wir bitten um euer Verständnis und versuchen, alle Probleme bestmöglich zu lösen :)</pre>
            <a type="button" class="btn btn-success btn-block" href="game.html">Zum Spiel!</a>
        </div>

        <div id="rulesHTML" class="hidden">
            <div class="row">
                <div class="col-sm-12">
                    <h3><b>Ziel des Spiels</b></h3>
                    <p>
                        Das Spiel ist sehr stark dem originalen <a href="http://www.agar.io">Agar.io</a> nachempfunden.
                        Ziel des Spiels ist es, möglichst lange zu überleben und möglichst viel Masse aufzubauen.
                    </p>
                    <p>
                        Dies wird erreicht, indem man Futter (grau) oder/und andere Spieler frisst.
                    </p>
                    <p class="further">
                        Für den Wettbewerb werden die Größe und Überlebenszeit nicht die einzigen Gewinn-Kriterien bleiben.
                        Weitere mögliche Gewinn-Kriterien können sein:
                        <ul class="further">
                            <li>Aggressivität</li>
                            <li>Anzahl gefressener gegnerischer Blobs</li>
                            <li>Anzahl gefressener Gegner (dass dieser ausscheidet)</li>
                            <li>Anzahl erfolgreiches Teilen (Gegnerische Blobs werden dabei gefressen)</li>
                            <li>Wie oft erfolgreich Gift in einen Gegner 'geworfen' wurde</li>
                            <li>Wie gut der Bot im Team spielt <u>(Noch nicht final!)</u></li>
                            <li>...</li>
                        </ul>
                    </p>
                </div>
            </div>
            <hr>
            <div class="row">
                <div class="col-sm-4">
                    <h3><b>Steuerung</b></h3>
                    <p>
                        Alle Blobs eures Programms werden als eine Einheit gesteuert und bewegen sich zu der
                        zuletzt genannten Zielposition (Letzte Ausgabe eures Programms).
                        Dabei können Blobs im Normalfall nicht ineinander fahren und werden vom Server bei einer Kollision
                        wieder auseinander geschoben.
                    </p>
                    <p class="further">
                        Die zuletzt genannte Zielposition wird beibehalten, bis sich euer Programm wieder meldet.
                        So ist es in Ordnung, wenn ihr länger für eine Berechnung braucht. Der Server nutzt in jedem Schritt
                        dann die alten Ziel-Koordinaten, bis diese erreicht wurden.
                    </p>
                    <p class="further">
                        Euer Programm bekommt danach wieder die aktuellsten Daten und überspringt dabei eventuell die Informationen
                        von ein paar Frames (Dies ist im Normallfall unkritisch). Es wird keine Queue aufgebaut.
                    </p>
                </div>
                <div class="col-sm-4">
                    <h3><b>Wann kann ich was fressen?</b></h3>
                    <h4>Futter</h4>
                    <p class="indent">
                        Futter kann immer gefressen werden.
                    </p>
                    <h4>Gegnerische Blobs</h4>
                    <p class="indent">
                        Gegnerische Blobs können gefressen werden, sobald der eigene Blob mindestens 10% größer ist.
                    </p>
                    <h4>Gift</h4>
                    <p class="indent">
                        Gift kann gefressen werden, wenn man insgesamt aus mehr als 10 Blobs besteht!
                    </p>
                    <p class="further indent">
                        Ausnahme: Das Gift wurde von einem anderen Spieler geteilt. Dann explodiert man trotzdem.
                    </p>
                </div>
                <div class="col-sm-4">
                    <h3><b>Aktionen</b></h3>

                    <h4>None</h4>
                    <p class="indent">
                        Man fährt ganz normal zu den gewählten Koordinaten
                    </p>

                    <h4>Split</h4>
                    <p class="indent">
                        Alle eigenen Blobs mit einer Größe von >= 100, teilen sich in Richtung der Ziel-Koordinaten.
                        Die geteilten und neuen Blobs haben danach 50% der ursprungs-Masse. Die gesamtmasse bleibt also gleich.
                    </p>
                    <p class="further indent">
                        Die neuen Blobs bekommen eine Beschleunigung in Richtung der Ziel-Koordinaten, die mit der Zeit abnimmt.
                    </p>

                    <h4>Throw</h4>
                    <p class="indent">
                        Alle eigenen Blobs mit einer Größe von >= 100, werfen ein Futter in Richtung der Ziel-Koordinaten.
                        Dieses verhält sich wie normales Futter.
                    </p>
                    <p class="further indent">
                        Das Futter hat eine Masse von 10. Die Masse wird von den eigenen Blobs abgezogen.
                    </p>
                    <p class="further indent">
                        Das Futter bekommt eine Beschleunigung in Richtung der Ziel-Koordinaten, die mit der Zeit abnimmt.
                    </p>
                </div>
            </div>
            <hr>
            <div class="row">
                <div class="col-sm-4">
                    <h3><b>Kollision eines Blobs mit Gift</b></h3>
                    <ul>
                        <li>
                            Gift kann gefressen werden, wenn man aus mehr als 10 Blobs besteht (Und mehr als 400 Masse hat).
                        </li>
                        <li>
                            Nichts passiert, wenn der Blob weniger als 400 Masse hat.
                        </li>
                        <li>
                            In allen anderen Fällen explodiert der Blob in 12 gleichgroße Blobs.
                            <p class="further">
                                Das Gift wird dabei gelöscht und ist nicht mehr vorhanden.
                            </p>
                            <p class="further">
                                Alle neuen Blobs bekommen eine Beschleunigung in zufällige Richtungen, die mit der Zeit abnimmt.
                            <p>
                        </li>
                    </ul>
                </div>
                <div class="col-sm-4">
                    <h3><b>Wiedervereinigen von Blobs</b></h3>
                    <p>
                        Blobs, die explodieren sind oder beim Teilen entstanden sind, können sich erst nach einer gewissen Zeit wiedervereinigen.
                    </p>
                    <p>
                        Die Wiedervereinigen von Blobs passiert automatisch.
                    </p>
                    <p class="further">
                        Geteilte oder explodierte Blobs bekommen einen Zeitraum zugewiesen (dieser kann sich evtl. aufaddieren), für den sie sich nicht wieder vereinigen
                        können. Nach Ablauf dieser Zeit findet eine Wiedervereinigung mit einem anderen eigenen Blob statt (nur bei Kontakt).
                    </p>
                    <p class="further">
                        Der Zeitraum bis zu einer Wiedervereinigung beträgt 10 Sekunden.
                    </p>
                </div>
                <div class="col-sm-4">
                    <h3><b>Ein Gift gezielt teilen</b></h3>
                    <p>
                        Gift ist in der Lage, Futter zu fressen.
                    </p>
                    <p>
                        Gift mit einer Masse von > 119 teilt sich in die gegensätzliche Richtung, von der das letzte Futter kam.
                    </p>
                    <p class="further">
                        Die Grundmasse von Gift ist 100. Ein Gift teilt sich also nach Aufnahme von 2 Futter.
                    </p>
                    <p class="further">
                        Dieser Umstand kann gezielt genutzt werden, um große, gegnerische Blobs, zum Explodieren zu bringen.
                    </p>
                    <p class="further">
                        Um Futter in das Gift zu 'pumpen', ist es am Einfachsten, auf das Gift zu zufahren und dabei >=2x in Folge
                        Futter abzugeben (Throw).
                    </p>
                    <p class="further">
                        Das neue Gift bekommt eine Beschleunigung, welche mit der Zeit abnimmt.
                    </p>
                </div>
            </div>
            <hr>
            <div class="row">
                <div class="col-sm-4">
                    <h3><b>Allgemeines</b></h3>
                    <p>
                        Je größer Blobs sind, desto langsamer werden sie.
                    </p>
                    <p>
                        Jeder Bot sieht nur einen kleinen Ausschnitt des Spielfeldes (Sichtfenster).
                    </p>
                    <p>
                        Je größer die Gesamtmasse eines Bots ist, desto größer ist das Sichtfenster des Bots.
                    </p>
                    <p>
                        Ein Bot kann nie aus mehr als 18 Blobs bestehen.
                    </p>
                    <p>
                        Die Spielfeldgröße liegt aktuell bei 1000x1000. Bis zur Bekanntgabe der Wettbewerbsbedingungen behalten wir uns vor, diese zu ändern.
                    </p>
                </div>
                <div class="col-sm-4">
                    <h3><b>Tipps</b></h3>
                    <p>
                        Um kleinere Gegner zu fressen, man kann sich in die Richtung des Gegners teilen und so diesen evtl. einholen und fressen.
                    </p>
                    <p>
                        Man kann versuchen, Gegner in eine Ecke oder den Rand des Spielfeldes zu drängen.
                    </p>
                    <p>
                        Wenn ein Blob explodiert ist, ist er leichtes Futter und für eine gewisse Zeit (relativ) wehrlos.
                    </p>
                    <p>
                        Wenn man sich teilt, ist man schneller (weil kleiner).
                    </p>
                    <p>
                        Wenn sich ein Gegner teilt, um einen zu fressen, kann man meistens überleben, indem man sich auch teilt, um zumindest die Hälfte
                        der eigenen Blobs zu retten.
                    </p>
                </div>
            </div>
        </div>
        <div id="contactHTML" class="hidden">
            <h4>Organisatoren</h4>
            <div>
                <p>
                    Maurice Tollmien (inf101074)
                </p>
                <p>
                    Henrik Patjens (hpa)
                </p>
            </div>
            <hr>

            <h4>Teilnahme</h4>
            <div>
                <p>
                    Jeder, ob Auszubildender an der PTL, Student der FH-Wedel, Mitarbeiter der FH-Wedel oder externe Personen, können an dem ausgeschriebenen Wettbewerb teilnehmen.
                </p>
                <p>
                    Um teilzunehmen, schreibt bitte eine E-Mail an Maurice Tollmien:
                </p>
                <div style="margin: 20px;">
                    <a href="mailto:inf101074@fh-wedel.de">inf101074@fh-wedel.de (Maurice Tollmien)</a><br>
                </div>
                <p>
                    Mit folgenden Informationen: <b>Voller Name, Matrikelnummer (wenn immatrikuliert)</b>
                </p>
            </div>
            <hr>
            <h4>Kommunikation</h4>
            <div>
                <p>
                    Wie bei jedem Programmierwettbewerb, wird die Kommunikation hauptsächlich durch die Newsgroup <code>fhw.Programmierwettbewerb</code> laufen.
                </p>
                <p>
                    Dort werden auch öffentliche Tests oder Änderungen jeglicher Art angekündigt. Außerdem könnt ihr über Strategien, Bots und
                    technische Details diskutieren.
                </p>
                <p>
                    Bei Fragen, die für andere Teilnehmer nicht interessant sind, könnt ihr gerne E-Mails schreiben oder uns privat ansprechen.
                </p>
            </div>
            <hr>
            <h4>Erreichbarkeit</h4>
            <div>
                <p>
                    Für Fragen, Diskussionen oder Hinweise auf folgenden Wegen erreichbar:
                </p>
                <p>
                    <ul>
                        <li>Newsgroup: <code>fhw.Programmierwettbewerb</code></li>
                        <li>Per Mail</li>
                        <li>
                            Bei Henrik Patjens im Büro. Raum: N18.<br>
                            Den Raum findet ihr im 1. Stock des EDV-Gebäudes. Hinter RZ 3/4 die Treppe hoch, dann rechts in die Robotik und nochmal wieder rechts.
                        </li>
                        <li>
                            Wann immer ihr uns auf dem Gang seht und wir nicht so gucken, als wenn wir hoch gestresst wären ;)
                        </li>
                    </ul>
                </p>
            </div>
            <hr>

        </div>

        <div id="botDevelopmentHTML" class="hidden">
            <h1>Einleitung</h1>
            <hr>
            <div>
                <p>
                    Alle Berechnungen zur Änderung des Spielzustands werden von einem Server übernommen. Pro Berechnungsschritt übermittelt
                    dieser euren Bots den aktuellen Spielzustand, den ihr anschließend auswerten und in ein Kommando übersetzen müsst. Dieses müsst ihr
                    dem Server zurückschicken, um die nächste Handlung eures Bots bekannt zu geben.
                <p>
                </p>
                    Damit ihr euch keine Gedanken, um die konkrete Übertragung von Daten zum Server machen müsst, haben wir ein kleines Program geschrieben, das euch diese Aufgabe abnimmt. Diese Middleware startet eure Bots, leitet ihnen die Daten von Server über <code>stdin</code> weiter und wartet dann auf die Antwort eures Bots über <code>stdout</code>, um
                    diese anschließend wieder zum Server zu schicken.
                </p>
                <center><img src="Images/InformationFlow1.png" alignment="center" /></center>
                <h4>Programmiersprachen</h4>
                <p>
                    Es gibt keine Enschränkungen bzgl. der Programmiersprache. Wenn Compiler oder Interpreter im Rechenzentrum nicht installiert sind, sagt uns bitte bescheid und wir werden diese nachinstallieren.
                </p>

                <h4>Testen</h4>
                <p>
                    Testen könnt ihr eure Bots auf einem Server der FH-Wedel. Wenn ihr euch mit der Middleware auf den Server verbindet, wird dort <i>kein</i> neues Spiel für euch gestartet. Alle Bots befinden sich auf dem selben Spielfeld und können live gegeneinander antreten.
                </p>
                <p>
                    Die Middleware zum Starten eurer Bots könnt ihr <a href="https://github.com/hpatjens/Programmierwettbewerb/raw/master/Programmierwettbewerb-Middleware">hier</a> herunterladen. Wir stellen jedoch nur eine 64-Bit Version für Linux bereit, da wir diese auch im Wettbewerb verwenden werden. Eine Installation ist nicht notwendig. Wenn wir euch ein Repository anlegen, werden wir euch die Middleware dort ebenfalls bereitstellen.<br>
                </p>
                <p>
                    Zum Starten eures Bots mit Hilfe der Middleware müsst ihr die config-Datei <code>middleware.conf</code> anpassen. Diese sollte wie folgt aussehen:
                </p>
                <pre>
bot=mybot
name=myname</pre>
                <dl class="dl-horizontal">
                    <dt>mybot</dt>
                    <dd>
                        Im einfachsten Fall ist dies nur eine ausführbare Datei. Wenn ihr eurem Programm Parameter übergeben wollt könnt ihr diese hier ebenfalls angeben. Auch ein Interpreter kann hier angegeben werden.
                    </dd>
                    <dt>myname</dt>
                    <dd>Hier gebt ihr den Namen an, unter dem ihr testen wollt. Dieser muss in der Datei <code>bot.names</code> in eurem Repository hinterlegt sein. Im Wettbewerb werden wir eurem Bot den Namen zuordnen, der hier eingetragen ist.</dd>
                </dl>

                Starten der Middleware:
                <pre>
./Programmierwettbewerb-Middleware</pre>
                <p>
                    Die folgenden Parameter könnt ihr <i>optional</i> angeben. Diese überscheiben eure Angaben in der <code>middleware.conf</code>.
                </p>
                <dl class="dl-horizontal">
                    <dt>-bot</dt>
                    <dd>Zur Angabe eures Bots. Hier gelten die gleichen Bedingungen wie in der <code>middleware.conf</code></dd>
                    <dt>-name</dt>
                    <dd>Euer Name für diesen Test. Dieser muss in der Datei <code>bot.names</code> in eurem Repository hinterlegt sein.</dd>
                    <dt>-numBots</dt>
                    <dd>Anzahl der Bots, die ihr starten wollt. Standardmäßig startet die Middleware einen Bot.</dd>
                </dl>
                <p>
                    Wenn ihr euch die Middleware selbst kompilieren wollt, könnt ihr dies selbstverständlich tun. Die Quellen findet ihr im <a href="https://github.com/hpatjens/Programmierwettbewerb/">Repository</a>.
                </p>
            </div>

            <h1>Repositories</h1>
            <hr>
            <p>
                Für den Wettbewerb stellen wir euch SVN-Repositories bereit. Schreibt uns einfach eine Mail und wir schalten euch ein Repository frei. Unsere E-Mail Adressen findet ihr unter Kontakt.
            </p>
            <p>
                Die Repositories findet ihr unter folgendem Link:<br>
                <div style="margin: 20px;">
                    <code>https://stud.fh-wedel.de/repos/pwb_ws2016/pwb_xx</code><br>
                </div>
            </p>

            <h1>Vorgaben</h1>
            <hr>
            <div class="row">
                <div class="col-sm-6">
                    <h3>Executable</h3>
                    <h4>Betriebssystem</h4>
                    <p class="indent">
                        Im Wettbewerb werden wir alles auf einem <b>64-Bit Linux</b> ausführen!
                    </p>

                    <h4>Zusatzinformation für Faule</h4>
                    <p class="indent">
                        Die ausführbare Datei muss eigentlich erst für den Wettbewerb korrekt in der middleware.conf eingetragen sein. Wird würden jedoch gerne vorab einige Tests
                        machen und bitten euch immer eine ausführbare Datei einzutragen. Dies erleichtert euch zudem das Testen.
                    </p>
                </div>
                <div class="col-sm-6">
                    <h3>Bot-Namen</h3>

                    <h4>Namen zum Testen eintragen</h4>
                    <p class="indent">
                        Jedes SVN-Repository enthält eine Datei mit dem Namen <code>bot.names</code>. Diese kann beliebig editiert werden und enthält pro Zeile einen
                        Namen, unter denen ihr euren Bot auf unserem Server testen könnt. Einen der eingetragenen Namen könnt ihr mit dem <code>-name</code>-Flag der Middleware angeben.
                        Um eine Eindeutigkeit zu gewährleisten, denkt euch bitte eindeutige Namen aus oder nutzt einen originellen Präfix für eure Bots.
                    </p>

                    <h4>Name im Wettbewerb</h4>
                    <p class="indent">
                        Im Wettbewerb wird der erste Eintrag (1. Zeile) der <code>bot.names</code> als offizieller Bot-Name genutzt. Bitte tragt dort euren
                        finalen Wunschnamen ein.
                    </p>

                    <h4>Hintergrund</h4>
                    <p class="indent">
                        Grund dafür ist, dass wir auf dem Server Statistiken für jedes Repository führen. Gleichzeitig möchten wir die Möglichkeit bieten,
                        anonym zu testen, dass andere Mitspieler nicht wissen, von wem der großartige Super-Bot grade ist, der alles auf dem Server auffrisst. :)
                        Bots mit Namen, welche nicht in der (hochgeladenen) bot.names auftauchen, werden vom Server abgewiesen.
                        <p class="further indent">
                            Der Server macht selbstständig SVN-Updates und vergleicht die Einträge der bot.names mit dem angegebenen Namen von der Middleware.
                            Die Updates erfolgen jedoch nur alle paar Minuten. Daher kann es sein, dass ihr nach einem 'SVN commit' ein paar Minuten warten müsst,
                            bis ihr mit den neuen Nicknames testen könnt.
                        </p>
                    </p>

                    <h4>Eigene Namen verwenden</h4>
                    <p class="indent">
                        Bitte nehmt davon Abstand, unter fremden Namen zu testen. Wiederholtes Verletzen dieser Regel kann zur <b>Disqualifikation</b>
                        führen (Ja, wir loggen alle Daten dazu ;)).
                    </p>
                </div>
            </div>

            <h1 class="offset">Datenformate</h1>
            <hr>
            <p>
                Die Middleware schickt euch die Daten in einem an Python-orientierten Format und erwartet dies auch von euren Bots.
            </p>
            <div class="row">
                <div class="col-sm-6">
                    <h3>Eingabe <small>für eure Bots von der Middleware</small></h3>
                    <pre>
type BotId      = Int
type TeamId     = Int
type Index      = Int
type Position   = (Float, Float)
type Mass       = Int
type Blob       = (BotId, TeamId, BlobId, Position, Mass)
type Food       = (Position, Mass)
type Toxin      = (Position, Mass)
type OwnBlobs   = [Blob]
type OtherBlobs = [Blob]

<b>type Input      = (OwnBlobs, OtherBlobs, [Food], [Toxin])</b></pre>
                </div>
                <div class="col-sm-6">
                    <h3>Ausgabe <small>von euren Bots an die Middleware</small></h3>
                    <pre>
data BlobAction = None | Throw | Split
type Position   = (Float, Float)

<b>type Output     = (BlobAction, Position)</b></pre>
                </div>
            </div>
            <h3>Beispiel</h3>
            <div class="row">
                <hr>
                <img class="img-responsive img-center" src="Images/DataFormatField.jpg" />
                <hr>
            </div>
            <div class="row">
                <div class="col-sm-6">
                    <h4>Eingabe im Beispiel <small>(Zeilenumbrüche nicht berücksichtigen)</small></h4>
                    <pre>
    ([(3,0,1,(8.0,7.0),100)],
     [(13,1,4,(4.0,3.0),100)],
     [((6.5,1.5),10)],
     [((2.0,6.0),10)])</pre>
                </div>
                <div class="col-sm-6">
                    <h4>Ausgabe im Beispiel</h4>
                    <pre>
    (None,(9.0,2.5))</pre>
                </div>
            </div>
            <h1 class="offset">Parser</h1>
            <hr>
            <p>In dieser Übersicht sehr ihr, wie ihr die Eingabe in verschiedenen Sprachen parsen könnt.</p>
            <div class="row">
                <div class="col-md-12">
                    <table class="table table-striped">
                        <thead>
                            <tr>
                                <th>Sprache</th>
                                <th>Parser</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Python</td>
                                <td>Die Eingabe kann mit der Funktion <code>eval</code> geparst werden.</td>
                            </tr>
                            <tr>
                                <td>C</td>
                                <td><a target="_blank" href="https://github.com/hpatjens/Programmierwettbewerb/blob/master/BotCpp/BotCpp/pwb.h">Hier</a> stellen wir einen Parser bereit.</td>
                            </tr>
                            <tr>
                                <td>Haskell</td>
                                <td>Wenn ihr die entsprechenden Datenstrukturen anlegt, könnt ihr die Eingabe mit <code>read</code> (Typklasse <code>Read</code>) einlesen.</td>
                            </tr>
                            <tr>
                                <td>...</td>
                                <td></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <p>Bitte sagt Bescheid, wenn ihr weitere Sprachen kennt, mit denen dieses Format leicht zu parsen ist. Wenn ihr eure Parser anderen Teilnehmern bereitstellen wollt, nehmen wir diese natürlich auch gerne in diese Auflistung auf.</p>
            <h1 class="offset">Beispiel-Bots</h1>
            <hr>
            <div class="row">
                <div class="col-sm-6">
                    <h3>Python</h3>
                    <pre>
def process(data) {
     // TODO: Calculate the target and action of your bot!
}

while (1):
    line = sys.stdin.readline()
    data = eval(line)
    print process(data)</pre>
                    <a href="https://github.com/hpatjens/Programmierwettbewerb/tree/master/BotPython" class="btn btn-default">Show in Repository</a>
                </div>
                <div class="col-sm-6">
                    <h3>C</h3>
                    <pre>
#define PWB_IMPLEMENTATION
#include "pwb.h"

BotCommand process(const VisibleGameState* const visibleGameState) {
    Vec2 target;
    BotActionType botActionType;

    // TODO: Calculate the target and action of your bot!

    return pwb_mkBotCommand(botActionType, &target);
}

int main() {
    #define INPUT_BUFFER_MAX_LENGTH 20000
    #define OUTPUT_BUFFER_MAX_LENGTH 100

    char inputBuffer[INPUT_BUFFER_MAX_LENGTH];
    char outputBuffer[OUTPUT_BUFFER_MAX_LENGTH];

    for (;;) {
        pwb_getline(inputBuffer, INPUT_BUFFER_MAX_LENGTH);

        ParseContext parseContext = pwb_mkContext(inputBuffer);

        VisibleGameState visibleGameState;
        if (!pwb_parseAll(&parseContext, &visibleGameState)) {
            pwb_printErrors(&parseContext, stderr);
            exit(1);
        }

        BotCommand botCommand = process(&visibleGameState);

        pwb_toString(outputBuffer, &botCommand);
        printf("%s\n", outputBuffer);
        fflush(stdout);
    }

    return 0;
}</pre>
                    <a href="https://github.com/hpatjens/Programmierwettbewerb/tree/master/BotCpp" class="btn btn-default">Show in Repository</a>
                </div>
            </div>
        </div>
        <div id="simulationsHTML" class="hidden">
            <h1>Allgemeines</h1>
            <hr>
            <div class="row">
                <div class="col-sm-4">
                    <h3>Main-Loop</h3>
                    <p>
                        Der Server führt alle Simulationen mit einer konstanten Frequenz von 30Hz aus. D.h. zwischen den Simulationsschritten liegen etwas über &Delta;t = 33ms. Wird die Frequenz belastungsbedingt nicht erreicht, rechnen wir jedoch trotzdem mit dem selben &Delta;t. Dadurch erreichen wird stabile Simulationen jedoch läuft das Spiel in diesem Moment langsamer.
                    </p>
                    <p>
                        Die Reihenfolge der Simulationen ist nicht-deterministisch. Das bedeutet, ihr könnt keine Vor- oder Nachteile durch die Simulationsreihenfolge erlangen.
                    </p>
                    <p>

                    </p>
                </div>
                <div class="col-sm-4">
                    <h3>Spawnen von Spielelementen</h3>
                    <p>
                        ...
                    </p>
                </div>
                <div class="col-sm-4">
                    <h3>Geschwindigkeit und Position</h3>
                    <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit...</p>
                    <p>Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris...</p>
                </div>
            </div>
            <hr>
            <h1>Aktionen</h1>
            <div class="row">
                <div class="col-sm-4">
                    <h3>Teilen und Explodieren</h3>
                    <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit...</p>
                    <p>Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris...</p>
                </div>
                <div class="col-sm-4">
                    <h3>Masse werfen und Teilen von Gift</h3>
                    <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit...</p>
                    <p>Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris...</p>
                </div>
            </div>
        </div>
        <nav class="navbar navbar-default navbar-static-top">
            <div class="container">
            <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="#">Programmierwettbewerb</a>
            </div>
            <div id="navbar" class="navbar-collapse collapse">
                <ul class="nav navbar-nav">
                    <li class="active" id="mnuHome"><a href="#">Home</a></li>
                    <li id="mnuRules"><a href="#">Spielregeln</a></li>
                    <li id="mnuBotDevelopment"><a href="#">Bot-Entwicklung</a></li>
                    <li id="mnuContact"><a href="#">Kontakt</a></li>
                    <!--<li id="mnuSimulations"><a href="#">Server-Simulationen</a></li>-->
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="https://github.com/hpatjens/Programmierwettbewerb">Repository</a></li>
                </ul>
            </div><!--/.nav-collapse -->
            </div>
        </nav>

        <div id="container" class="container">
        </div>
    </body>
</html>
